C51 COMPILER V9.59.0.0   RTC_SYS                                                           04/24/2025 12:33:10 PAGE 1   


C51 COMPILER V9.59.0.0, COMPILATION OF MODULE RTC_SYS
OBJECT MODULE PLACED IN .\Objects\rtc_sys.obj
COMPILER INVOKED BY: D:\Keil\Keil_C51\C51\BIN\C51.EXE Sources\rtc_sys.c LARGE OMF2 OPTIMIZE(8,SPEED) BROWSE DEBUG PRINT(
                    -.\Listings\rtc_sys.lst) TABS(2) OBJECT(.\Objects\rtc_sys.obj)

line level    source

   1          #include "rtc_sys.h"
   2          
   3          
   4          u16    xdata        SysTick_RTC=0;
   5          bit                 RTC_Flog=0;
   6          
   7          //=====================================
   8          //void Sys_Cpu_Init()
   9          //{
  10          //        IEN0       = 0x00;             //IEN0.7=EA ÖÐ¶Ï×Ü¿ØÖÆ .6=0£¬.5=ET2£¬.4=ES0£¬.3=ET1£¬.2=EX1£¬.1=ET0£¬.0=
             -EX0   ES0 ´®¿Ú2 ½ÓÊÜ+·¢ËÍÖÐ¶Ï
  11          //      IEN1       = 0x00;             //IEN1.7=0£¬.6=0£¬.5=´®¿Ú5½ÓÊÜÖÐ¶Ï,.4=´®¿Ú5·¢ËÍÖÐ¶Ï,.3=´®¿Ú4½ÓÊÜÖÐ¶Ï,.2=´®¿
             -Ú4·¢ËÍÖÐ¶Ï,.1=canÖÐ¶Ï
  12          //      IEN2       = 0x00;             // .7-.1=0 , .0=ES1 ´®¿Ú3 ½ÓÊÜ+·¢ËÍÖÐ¶Ï 
  13          ////========================================MODE      
  14          //      DPC = 0x00;                          //DPTR ÊÇ·ñ+1 C51=0
  15          //      CKCON      = 0x00;                     //CPUÔËÐÐ=0, 1TÄ£Ê½
  16          //    
  17          //      IP0 = 0x00;IP1 = 0x00;               //ÖÐ¶ÏÓÅÏÈ¼¶Ä¬ÈÏ
  18          //      RAMMODE = 0x00;
  19          ////========================================IO³õÊ¼»¯          
  20          //      P0MDOUT    =0x53;            //p0.0 p0.1 Ç¿ÍÆ ÓÃÓÚ485·½Ïò¿ØÖÆ P0.4Òý³öµ½´®¿Ú2 P0.6Òý³öµ½´®¿Ú3
  21          //      P2MDOUT    =0xC0; 
  22          //      P3MDOUT    =0x0C;            //¿ªÆôP3_2ºÍP3_3µÄÊä³ö P3_2=RTC_SCL P3_3=RTC_SDA
  23          //      PORTDRV    = 0x01;             //IOÇý¶¯ÄÜÁ¦Éè¶¨ 4mA=0,8mA=1,16mA=2,32mA=3
  24          //      P2         = 0XC0;
  25          //      P3         = 0x00; 
  26          //      WDT_OFF();        //¹Ø±Õ¿ªÃÅ¹·    
  27          ////========================================
  28          //      TH2 = 0x00;
  29          //      TL2 = 0x00;
  30          //      T2CON = 0x70;
  31          //      TRL2H = 0xBC; //1msµÄ¶¨Ê±Æ÷
  32          //      TRL2L = 0xCD;
  33          //      IEN0 |= 0x20; //Æô¶¯¶¨Ê±Æ÷2
  34          //      TR2 = 0x01;
  35          //      ET2 = 1;        //T2¶¨Ê±Æ÷ÖÐ¶ÏÊ¹ÄÜ¿ØÖÆÎ»
  36          //      EA  = 1;
  37          
  38          //}
  39          /****************************************************************************/
  40          //void Sys_Timer2_isr() interrupt 5   //1MS
  41          //{
  42          //          TF2=0;//Çå³ý¶¨Ê±Æ÷2µÄÖÐ¶Ï±êÖ¾Î»
  43          //          if(TimVal<255)TimVal++;
  44          //          SysTick_RTC++;
  45          ////          if(T_O5>0)T_O5--;
  46          ////          if(T_O4>0)T_O4--;
  47          ////          if(T_O3>0)T_O3--;
  48          ////          if(T_O2>0)T_O2--;
  49          //          if(Count_num1>0) Count_num1--; 
  50          //}
  51          /****************************************************************************/
  52          u16 Read_Dgus(u16 Dgus_Addr)
C51 COMPILER V9.59.0.0   RTC_SYS                                                           04/24/2025 12:33:10 PAGE 2   

  53          {         u16 R_Dgus=0;
  54   1            EA = 0;
  55   1            ADR_H = 0x00;
  56   1            ADR_M = (u8)((Dgus_Addr/2)>>8);
  57   1            ADR_L = (u8)(Dgus_Addr/2);
  58   1            RAMMODE = 0xAF;   //¶Á²Ù×÷
  59   1            while(!APP_ACK);
  60   1            APP_EN = 1;
  61   1            while(APP_EN);
  62   1            if(Dgus_Addr%2) R_Dgus = (DATA1<<8)+DATA0; 
  63   1            else   R_Dgus=(DATA3<<8)+DATA2;
  64   1            RAMMODE = 0;
  65   1            EA = 1;
  66   1            return   R_Dgus;    
  67   1      }
  68          /****************************************************************************/
  69          void Write_Dgus(u16 Dgus_Addr,u16 Val)
  70          {          
  71   1            EA = 0;
  72   1            ADR_H = 0x00;
  73   1            ADR_M = (u8)((Dgus_Addr/2)>>8);
  74   1            ADR_L = (u8)(Dgus_Addr/2);
  75   1            RAMMODE = 0xAF;   //¶Á²Ù×÷
  76   1            while(!APP_ACK);
  77   1            APP_EN = 1;
  78   1            while(APP_EN);
  79   1            RAMMODE = 0;
  80   1              ADR_M = (u8)((Dgus_Addr/2)>>8);
  81   1            ADR_L = (u8)(Dgus_Addr/2);
  82   1            RAMMODE = 0x8F;   //Ð´²Ù×÷
  83   1              while(!APP_ACK);
  84   1            if(Dgus_Addr%2){DATA1=(u8)(Val>>8); DATA0=(u8)(Val); }
  85   1            else { DATA3 =(u8)(Val>>8); DATA2 =(u8)(Val);}
  86   1              APP_EN = 1;
  87   1            while(APP_EN);
  88   1            RAMMODE = 0;
  89   1            EA = 1;
  90   1      }
  91          //======================================
  92          /**************************************************************************   ***
  93           º¯ Êý Ãû  : void write_dgus_vp(u32 addr,u8* buf,u16 len)
  94           ¹¦ÄÜÃèÊö  : Ð´dgusµØÖ·Êý¾Ý
  95          ÊäÈë²ÎÊý  :  addr£ºÐ´µØÖ·Öµ buf£ºÐ´ÈëµÄÊý¾Ý±£´æ»º´æÇø len£º×Ö³¤¶È
  96           Êä³ö²ÎÊý  : 
  97           ÐÞ¸ÄÀúÊ·  :
  98            1.ÈÕ    ÆÚ   : 
  99              ×÷    Õß   : 
 100              ÐÞ¸ÄÄÚÈÝ   : ÐÞ¸Ä¶ÁÐ´dgusÁ÷³Ì£¬²»Ê¹ÓÃÇ¶Ì×
 101          *****************************************************************************
 102          void write_dgus_vp(unsigned int addr,unsigned char *buf,unsigned int len)
 103          {
 104            unsigned char i;
 105          
 106          //  EA = 0;
 107            i=(unsigned char)(addr&0x01);
 108            addr=addr/2;
 109            ADR_H=0x00;
 110            ADR_M=(unsigned char)(addr>>8);
 111            ADR_L=(unsigned char)(addr);
 112            ADR_INC=0x01;
 113            RAMMODE=0x8F;
 114            while(APP_ACK==0);
C51 COMPILER V9.59.0.0   RTC_SYS                                                           04/24/2025 12:33:10 PAGE 3   

 115            if(i && len>0)
 116            {
 117              RAMMODE=0x83;
 118              DATA1=*buf++;
 119              DATA0=*buf++;
 120              APP_EN=1;
 121              while(APP_EN==1);
 122              len--;
 123            }
 124            RAMMODE=0x8F;
 125            while(len>=2)
 126            {
 127              DATA3=*buf++;
 128              DATA2=*buf++;
 129              DATA1=*buf++;
 130              DATA0=*buf++;
 131              APP_EN=1;
 132              while(APP_EN==1);
 133              len=len-2;
 134            }
 135            if(len)
 136            {
 137              RAMMODE=0x8C;
 138              DATA3=*buf++;
 139              DATA2=*buf++;
 140              APP_EN=1;
 141              while(APP_EN==1);
 142            }
 143            RAMMODE=0x00;
 144          //  EA = 1;
 145          }
 146          /*****************************************************************************/
 147          #if 0
              void Write_Dgusii_Vp_byChar(unsigned int addr,unsigned char *buf,unsigned int len){
                unsigned char i;
              //  bit EA_Bak;
              //  EA_Bak = EA;
                EA = 0;
                i = (unsigned char)(addr & 0x01);
                addr = addr / 2;
                ADR_H = 0x00;
                ADR_M = (unsigned char)(addr >> 8);
                ADR_L = (unsigned char)(addr);
                ADR_INC = 0x01;
                RAMMODE = 0x8F;
                while(APP_ACK == 0);
                if(i && len > 0){
                  if(len == 1){
                    RAMMODE = 0x82;
                    DATA1 = *buf++;
                    APP_EN = 1;
                    while(APP_EN == 1);
                    len--;
                  } else {
                    RAMMODE = 0x83;
                    DATA1 = *buf++;
                    DATA0 = *buf++;
                    APP_EN = 1;
                    while(APP_EN == 1);
                    len -= 2;
                  }
                }
C51 COMPILER V9.59.0.0   RTC_SYS                                                           04/24/2025 12:33:10 PAGE 4   

                RAMMODE = 0x8F;
                while(len >= 4){
                  DATA3 = *buf++;
                  DATA2 = *buf++;
                  DATA1 = *buf++;
                  DATA0 = *buf++;
                  APP_EN = 1;
                  while(APP_EN == 1);
                  len -= 4;
                }
                
                if(len == 3){
                  RAMMODE = 0x8E;
                  DATA3 = *buf++;
                  DATA2 = *buf++;
                  DATA1 = *buf++;
                  APP_EN = 1;
                  while(APP_EN == 1);
                } else if(len == 2){
                  RAMMODE = 0x8C;
                  DATA3 =* buf++;
                  DATA2 =* buf++;
                  APP_EN = 1;
                  while(APP_EN == 1);
                } else if(len == 1){
                  RAMMODE = 0x88;
                  DATA3 = *buf++;
                  APP_EN = 1;
                  while(APP_EN == 1);
                }
                RAMMODE = 0x00;
              //  EA = EA_Bak;
                EA=1;
              }
              
              /*****************************************************************************
               º¯ Êý Ãû  : void read_dgus_vp(u32 addr,u8* buf,u16 len)
               ¹¦ÄÜÃèÊö  : ¶ÁdgusµØÖ·µÄÖµ
               ÊäÈë²ÎÊý  : addr£ºdgusµØÖ·Öµ  len£º¶ÁÊý¾Ý³¤¶È
               Êä³ö²ÎÊý  : buf£ºÊý¾Ý±£´æ»º´æÇø
               ÐÞ¸ÄÀúÊ·  :
                1.ÈÕ    ÆÚ   : 
                  ×÷    Õß   : 
                  ÐÞ¸ÄÄÚÈÝ   : ÐÞ¸Ä¶ÁÐ´dgusÁ÷³Ì£¬²»Ê¹ÓÃÇ¶Ì×
              *****************************************************************************/
              void read_dgus_vp(unsigned int addr,unsigned char *buf,unsigned int len)
              {
                
                unsigned char i;
                i=(unsigned char)(addr&0x01);
                EA=0;
                addr=addr/2;
                ADR_H=0x00; 
                ADR_M=(unsigned char)(addr>>8);
                ADR_L=(unsigned char)(addr);
                ADR_INC=0x01;
                RAMMODE=0xAF;
                while(APP_ACK==0);
                while(len>0)
                {
                  APP_EN=1;
                  while(APP_EN==1);
C51 COMPILER V9.59.0.0   RTC_SYS                                                           04/24/2025 12:33:10 PAGE 5   

                  if((i==0)&&(len>0))
                  {
                    *buf++=DATA3;
                    *buf++=DATA2;
                    i=1;
                    len--;
                  }
                  if((i==1)&&(len>0))
                  {
                    *buf++=DATA1;
                    *buf++=DATA0;
                    i=0;
                    len--;
                  }
                }
                RAMMODE=0x00;
                EA=1;
              }
              #endif


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    158    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =      2    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      1    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
