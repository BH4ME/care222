C51 COMPILER V9.59.0.0   QRJ                                                               04/24/2025 18:24:29 PAGE 1   


C51 COMPILER V9.59.0.0, COMPILATION OF MODULE QRJ
OBJECT MODULE PLACED IN .\Objects\qrj.obj
COMPILER INVOKED BY: D:\Keil\Keil_C51\C51\BIN\C51.EXE PAGE\qrj.c LARGE OMF2 OPTIMIZE(8,SPEED) BROWSE INCDIR(.\Sources;.\
                    -APP;.\PAGE) DEBUG PRINT(.\Listings\qrj.lst) TABS(2) OBJECT(.\Objects\qrj.obj)

line level    source

   1          #include  "qrj.h"
   2          #include "dgus.h"
   3          #include "home.h"
   4          //气溶胶消毒
   5          double TIME_static=0.0;
   6          void QRJ_mm_to_s(u16 L_T);
   7          
   8          
   9          u8 current_st;
  10          //初始化0x00，第一次进入界面0x01，就绪态0x02（第一次进入界面只运行一次后，未执行任务），运行态0x03开始，
  11          //运行态暂停0x04，运行态结束0x05,复位0x06
  12          /*******************************************************
  13          //开机初始化QRJ_Init 只运行一次
  14          第一次进入界面（从别的页面跳转过来的），或者点击复位按键 QRJ_Reset 只运行一次
  15          在当前页面但未进行任务及未开始或未处于暂停状态QRJ_prepare
  16          进行任务中（处于开始或暂停状态，任务完成仍为开始状态）QRJ_run 但只有按键按的时候才执行
  17          ******************************************************/
  18          
  19          
  20          
  21          void QRJ_run()  //按下操作 正在照射   在handle.c中调用 局限性每次有按压反馈的时候才会调用
  22          {
  23   1      
  24   1      
  25   1      }
  26          
  27          
  28          void QRJ_Init()   //开机初始化
  29          {
  30   1        current_st = 0x00;
  31   1        
  32   1      }
  33          
  34          
  35          
  36          //u8 last_page;
  37          //主要功能解锁触控单元
  38          void  QRJ_Set()       //每次进入页面初始化
  39          {
  40   1      
  41   1      }
  42          
  43          void  QRJ_Reset()       //按下复位键 只进行一次 
  44          {
  45   1      
  46   1      }
  47            
  48          //    L_int   mm
  49          
  50          float qirongjiao_j=0.0;
  51          
  52          void QRJ_prepare()  //在当前页面 但未操作
  53          {
  54   1        u16 ResTime_sec;
C51 COMPILER V9.59.0.0   QRJ                                                               04/24/2025 18:24:29 PAGE 2   

  55   1        u16 ResTime_min;  
  56   1        u16 QRJ_mj; 
  57   1      
  58   1      
  59   1        ReadDGUS(0x5100,(uint8_t *)&QRJ_mj,sizeof(QRJ_mj));   //读取杀灭log值 范围1~5
  60   1        switch(QRJ_mj)
  61   1        {
  62   2          case 1:
  63   2          {
  64   3            qirongjiao_j  = 500;
  65   3            break;
  66   3          }
  67   2              case 2:
  68   2          {
  69   3            qirongjiao_j  = 1000;
  70   3            break;
  71   3          }
  72   2              case 3:
  73   2          {
  74   3            qirongjiao_j  = 1500;
  75   3            break;
  76   3          }
  77   2              case 4:
  78   2          {
  79   3            qirongjiao_j  = 2500;
  80   3            break;
  81   3          }
  82   2              case 5:
  83   2          {
  84   3            qirongjiao_j  = 4000;
  85   3            break;
  86   3          }
  87   2        }
  88   1        
  89   1        QRJ_mm_to_s(L_int); //根据距离和功率得到时间
  90   1        
  91   1        ResTime_min=(u16)(TIME_static)/16;
  92   1        ResTime_sec=(u16)(TIME_static)%16;
  93   1        WriteDGUS(0x2820,(uint8_t *)&ResTime_min,sizeof(ResTime_min));    /***剩余时间*分钟****/
  94   1        WriteDGUS(0x2800,(uint8_t *)&ResTime_min,sizeof(ResTime_min));    /***剩余时间*分钟****/
  95   1        WriteDGUS(0x2805,(uint8_t *)&ResTime_sec,sizeof(ResTime_sec));    /***剩余时间*秒****/
  96   1        WriteDGUS(0x2825,(uint8_t *)&ResTime_sec,sizeof(ResTime_sec));    /***剩余时间*秒****/
  97   1      
  98   1      }
  99            
 100            
 101            
 102          /******************输入距离给出时间 mm->s*********/
 103          u8 L_T_S_FLAG;
 104          
 105          void QRJ_mm_to_s(u16 L_T) 
 106          {
 107   1        double L_CM;
 108   1        L_CM=L_T/10.0;
 109   1        if(L_CM<400 && L_CM>5) L_T_S_FLAG=1;    //在5cm~4m范围
 110   1              else L_T_S_FLAG=5;
 111   1      
 112   1        switch(L_T_S_FLAG)
 113   1        {
 114   2          case 1:
 115   2          {
 116   3            TIME_static=qirongjiao_j/change_P_uW_doing;
C51 COMPILER V9.59.0.0   QRJ                                                               04/24/2025 18:24:29 PAGE 3   

 117   3            break;
 118   3          }
 119   2      
 120   2              default:
 121   2          {
 122   3            L_T_S_FLAG=6;
 123   3            
 124   3            break;
 125   3          }
 126   2        }
 127   1      }
 128          
 129          
 130          void QRJ_stop()
 131          {
 132   1        
 133   1      }
 134          
 135          
 136          
 137          void QRJ_Home() //循环运行
 138          {
 139   1        
 140   1          if(last_page!=CurrentPageNum[1])  //第一次进入页面
 141   1        {
 142   2          last_page=CurrentPageNum[1];  
 143   2          current_st = 0x01;
 144   2        }
 145   1      //  else 
 146   1      //  {
 147   1      //    
 148   1      //  } 
 149   1        
 150   1        switch(current_st)    //在handle.c触摸反馈中检测
 151   1        {
 152   2          case 0:   //开机初始化状态
 153   2          {
 154   3            current_st = 0x01;  //初始化成功，跳转到第一次初始化态
 155   3          //  break;
 156   3          }
 157   2          
 158   2          case 1:   //第一次初始化态
 159   2          {
 160   3            current_st = 0x02;  //第一次初始化成功，跳转到就绪态
 161   3            QRJ_Set();
 162   3            
 163   3          //  break;
 164   3          }
 165   2          
 166   2          case 2:   //就绪态
 167   2          {
 168   3            QRJ_prepare();
 169   3            break;
 170   3          }
 171   2          
 172   2              case 3:   //运行态开始
 173   2          {
 174   3            
 175   3            QRJ_run();
 176   3            break;
 177   3          }
 178   2          
C51 COMPILER V9.59.0.0   QRJ                                                               04/24/2025 18:24:29 PAGE 4   

 179   2              case 4:   //运行态暂停
 180   2          {
 181   3            QRJ_stop();
 182   3            break;
 183   3          }
 184   2          
 185   2              case 5:   //运行态结束 此为自然结束不包含复位
 186   2          {
 187   3            
 188   3            break;
 189   3          }
 190   2              case 6:   //运行态复位 只进行一次 然后跳转到第一次初始化
 191   2          {
 192   3            current_st = 0x01;  // 置位 到第一次初始化
 193   3            QRJ_Reset();  //只运行一次
 194   3            
 195   3            break;
 196   3          }
 197   2          
 198   2          default :
 199   2          {
 200   3            break;
 201   3          }
 202   2          
 203   2        }
 204   1        
 205   1        
 206   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    493    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =     10      10
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
